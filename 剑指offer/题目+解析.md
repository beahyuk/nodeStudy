# 剑指offer（JavaScript版本）

## 算法题目&解析

算法解析：<https://www.cnblogs.com/wuguanglin/category/1178569.html>

LeetCode网址：<https://leetcode-cn.com/>

LeetCod剑指offer题库：https://leetcode-cn.com/problemset/lcof/

牛客网剑指offer题库：https://www.nowcoder.com/ta/coding-interviews

## 1. 数组查找

### 题目描述

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

### 解析

因为数组是行递增，列递增，找到数组最左下角的数a进行判断，如果大于a，就往右走，col++。如果小于a，就往上找，row--

### 代码

```javascript
let array = [
    [1, 2, 3, 4, 5],
    [11, 12, 13, 14, 15],
    [21, 22, 23, 24, 25],
    [31, 32, 33, 34, 35]
];

function find(array, target) {
    let rowlen = array.length,
        collen = array[0].length;
    let row = rowlen - 1,
        col = 0;
    if (rowlen === 0 && collen === 0) {
        return -1
    }
    while (row >= 0 && col <= collen - 1) {
        if (target > array[row][col]) {
            col++;
        } else if (target < array[row][col]) {
            row--;
        } else return [row, col, array[row][col]]
    }
    return false
}

console.log(find(array, 23))
```



### 二分法查找数据

```javascript
let array = [1,3,2,7,4]; //乱序
//递增排序，二分法只适合递增数组
array.sort((a,b)=>a-b);
let end= array.length-1,
    start = 0;
let result = fn(array,2,start,end)
console.log(result);

function fn(array,target,start,end){
    if (start>end){
        return -1
    };
    let mid = parseInt((start+end)/2);
    if(target < array[mid]){
        end = mid-1;
        return fn(array,target,start,end);
    }else if(target > array[mid]){
        start = mid+1;
        return fn(array,target,start,end);
    }else{
        return mid
    };
};

```

## 2. 替换空格（简单）

### 题目描述

请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

### 解析

利用正则表达式 将空格转成%20

### 代码

```javascript
var replaceSpace = function(s) {
    return s.replace(/ /g, "%20");
    // \s 是匹配任何空白字符，包括空格，制表符，换页符等等
    // return s.replace(/\s/g, "%20");

};

let str = "we are happy";
console.log(replaceSpace(str))
```

## 3. 从尾到头打印链表（简单）（不懂）

### 题目描述

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

### 解析

逆序输出链表，可以利用数组的unshift方法，输出放在数组头部

然后让指针指向下一个

### 代码

```javascript
function reverPrint(head1) {
    let res = [];
    let pNode = head;
    while (pNode !== null) {
        res.unshift(pNode.val);
        pNode = pNode.next;
    }
    return res
}
```

## 4.重建二叉树(不懂)

### 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

### 解析

先根据前序的第一个是根节点，然后在中序中 以根节点为中心，一分为二，再对左右分别进行递归查找

### 代码

```javascript
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    // preorder:前序，中左右
    // inorder：中序，左中右
    /**
     * @param {number[]} preorder
     * @param {number[]} inorder
     * @return {TreeNode}
     */
    var buildTree = function(preorder, inorder) {
        if (preorder.length == 0 || inorder.length == 0) {
            return null
        }

        // 找到根位置，（0，根位置）是左边树，（根位置，末尾）是右边树
        const index = inorder.indexOf(preorder[0]);
        let left = inorder.slice(0, index),
            right = inorder.slice(index + 1);
        return {
            val: preorder[0],
            left: buildTree(preorder.slice(1, index + 1), left);
            right: buildTree(preorder.slice(index + 1), right)
        }
    };
```

### 3和4 链表不懂的点

3和4 在本地运行的时候，不懂构造函数TreeNode，this.val = val,this.right =right 指向

## 5.用两个栈实现队列

### 题目描述

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

### 解析

栈的特性是：后入先出。根据题目提示，使用 2 个栈即可。一个栈inStack用来存储插入队列的数据，一个栈outStack用来从队列中取出数据。

算法分为入队和出队过程。

入队过程：将元素放入 inStack 中。

出队过程：

outStack 不为空：弹出元素
outStack 为空：将 inStack 元素依次弹出，放入到 outStack 中（在数据转移过程中，顺序已经从后入先出变成了先入先出）
时间复杂度是 O(N)，空间复杂度是 O(N)。

### 代码

```javascript
var CQueue = function() {
    this.instack = [];
    this.outstack = []
};

CQueue.prototype.appendTail = function(value) {
    this.instack.push(value)
};

CQueue.prototype.deleteHead = function() {
    const { instack, outstack } = this;
    if (outstack.length) {
        return outstack.pop()
    } else {
        while (!instack.length) {
            outstack.push(instack.pop())
        }
        return outstack.pop() || -1
    }
}
```

## 6.旋转数组中的最小数字

### 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输入旋转数组的最小元素。例如，数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1

### 解析

原数组递增排序，那么该数组的所有片段都是递增排列，第一个不符合递增排列的元素就是旋转截断点，也就是最小值点，如果没有，就返回第一个元素

对数组进行遍历，因为原数组是递增的，所以如果找到比数组的第一个元素小的，返回这个小的数，否则就返回第一个元素

### 代码

```javascript
let arr = [3, 4, 5, 1, 2];
/**
 * @param {number[]} numbers
 * @return {number}
 */
var minArray = function(numbers) {
    if (numbers.length === 0) return 0
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] < numbers[0]) {
            return numbers[i]
        }
    }
    return numbers[0]
}
console.log(minArray(arr))
```

## 7.斐波那契数 - 7.22

### 题目描述

斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
给定 N，计算 F(N)。

首几个斐波那契数是：（从第二个开始是前两个数的和）

0,1,1,2,3,5,13,21,34

### 解析

由于斐波那契数，从第二个开始是前两个数的和，除了第0个和 第一个。

第一反应是用递归，但是递归算法时间复杂度大

采用动态规划，把每一个值都存储起来，最后返回最后一个值，就是F（N）

### 代码

```javascript
var fn = function(N){
    let arr = [0,1,1]; //现规定前三个数
    for(let i = 3; i <= N; i++){
        arr[i]=arr[i-1]+arr[i-2]
    };
    return arr[N]  // 返回最后一个值
}
console.log(fn(5))
```

## 8.跳台阶 - 7.23

### 题目描述

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法

### 解析

- n=1时，有1种跳法
- n=2时，有2种跳法
- n=3时，有3种跳法
- n=4时，有5种跳法
- n=5时，有8种跳法
- ……

因为青蛙只能跳1阶或2阶台阶，假设一共有n级台阶，第一阶有两种跳法

- 第一个跳了1阶，剩下的是f（n-1）种跳法
- 第一个跳了2阶，剩下的是f（n-2）种跳法

那n级台阶一共有 f(n)=f(n-1)+f(n-2) 种跳法。类似于斐波那契数列

### 代码

```javascript
/**
 * @param {number} N
 * @return {number}
 */
var fib = function(N) {
    let arr = [0, 1,2]; // 这里和斐波那契数列不同
    for (let i = 3; i <= N; i++) {
        arr[i] = arr[i - 1] + arr[i - 2]
    }
    return arr[N];
};
console.log(fib(7))
```

## 9.变态跳台阶 - 7.24

### 题目描述

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

### 解析

由第八题知道，f(n) = f(n-1)+f(n-2)

这次青蛙可以一次跳上n级，则

① f(n)=f(n-1)+f(n-2)+...+f(1)

② f(n-1) = f(n-2)+f(n-3)+...+f(1)

①-②得出 f(n) = 2*f(n-1)的推导公式

### 代码

```javascript
/**
 * @param {number} N
 * @return {number}
 */
var fib = function(N) {
    let arr = [0, 1, 2]; // 这里和斐波那契数列不同
    for (let i = 3; i <= N; i++) {
        arr[i] = 2 * arr[i - 1]  //这里和第八题不一样
    }
    return arr[N];
};
console.log(fib(7))
```

## 10.矩形覆盖 - 7.25

### 题目描述

我们可以用2\*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2\*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

### 解析

- n=0 时，有0种方法

- n=1 时，有1种方法
- n=2 时，有2种方法
- n=3 时，有3种方法
- ……类似于斐波那契数列

当有2*n的时候，第一种是竖着排，那剩下的是f(n-1),第一种是横着排，那剩下的是f(n-2).那么一共有f(n)=f(n-1)+f(n-2)

当横着排的时候，第一行占据了两列，第二行前两列没有被排，但是排的方法其实已经被固定了，也是横着排。如果还不清楚的话，看博客园的图解

### 代码

```javascript
/**
 * @param {number} N
 * @return {number}
 */
var fib = function(N) {
    let arr = [0, 1, 2]; // 这里和斐波那契数列不同
    for (let i = 3; i <= N; i++) {
        arr[i] = arr[i - 2] + arr[i - 1]
    }
    return arr[N];
};
console.log(fib(7))
```

## 11.二进制中1的个数 - 7.26

### 题目描述

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

### 解析

要求是输出该数二进制中1的个数，就先把整数转成二进制数，然后看有几个1

- 利用toString（2）的方法转为二进制
- 用正则表达式，str.match(/1/g),匹配出所有1的字符串的数组
- 返回的是数组的长度或者0

### 代码

````javascript
var hammingWeight = function(n){
    let str = n.toString(2).match(/1/g);
    return str?str.length:0
}
let res = hammingWeight(9);
console.log(res);
// 2
````

### 补充：toString()用法

**toString(base)**

方法`num.toString(base) ` 返回在给定`base`进制数字系统中`num`的字符串表示形式

举个例子：

```javascript
let num = 255;

console.log(num.toString(16));//ff
console.log(num.toString(2)); // 11111111
```

`base`的范围可以从`2`到`36`。默认情况下是10。

常见的用例如下：

- **base = 16** 用于十六进制颜色，字符编码等，数字可以是`0..9`或`A..F`
- **base = 2** 主要用于调试按位操作，数字可以是`0`或`1`
- **base = 36** 是最大进制，数字可以是`0..9`或`A..Z`。所有拉丁字母都被用于了表示数字，对于`36`进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的URL。可以简单地使用基数为`36`的数字系统表示

## 12.数值的整数次方 - 7.27

### 题目描述

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0

### 解析

用js库自带的Math方法，Math.pow(n,power)

### 代码

```javascript
function power(base, exponent) {
    let res = Math.pow(base, exponent);
    return res;
}
let result = power(2, 2);
console.log(result)
```

### 补充：Math.pow(n,power)

**Math.pow(n,power)**

返回`n`的给定（power）次幂

```javascript
console.log(Math.pow(2,10)); // 2 的 10 次幂 = 1024
```

## 13.调整数组顺序使奇数位于偶数前面 - 7.27

### 题目描述

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
// 保持相对位置不变，例如1在3之前，奇数放前面后也是1在3之前
```

### 解析

首先判断奇数是` i%2 !==0`

先定义两个数组，奇数数组和偶数数组，然后把它们拼接

对数组进行遍历，如果`i%2 !==0`则是奇数，push给奇数数组，否则给偶数数组

### 代码

```javascript
const exchange = function (nums){
    const odd = []; // 奇数数组
    const arr = []; // 偶数数组
    nums.forEach(item => {
        item%2 ? odd.push(item) : arr.push(item);
    })
    return  odd.concat(arr)
}
```

## 14.链表中倒数第k个节点 - 7.28

### 题目描述

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

### 解析

看到要求输出倒数第k个节点，而且是链表，想办法转成 **栈** 储存的空间

- 用指针head一个一个push到定义的空栈中，这样倒数第k个节点变成正数第k个
- 如果k不为0，则栈一个个pop弹出，直到k为0，进不去循环，返回k=1的时候弹出的值

### 代码

```javascript
var getKthFromEnd = function (head,k){
    const stack =[];
    const res = [];
    // 如果head不为空，就push到栈
    while(head){
        stack.push(head);
        head = head.next;
    };
    whie(k>0){
        res = stack.pop();
        k--
    };
    return k
}
```

### 补充：

该算法无法运行，因为是链表，不知道怎么传参head 。而且head.next也不会

## 15.翻转链表 - 7.28

### 题目描述

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

### 解析

不懂，终究还是不懂链表。考试的时候最讨厌反转链表了

至少需要三个指针pPre（指向前一个结点）、pCurrent（指向当前的结点，在代码中就是pHead）、pNext（指向后一个结点）。

### 代码

```javascript
var reverseList = function(head) {
    let pPre = null;
    let pNext = null;
    while (head !== null) {
        pNext = head.next;
        head.next = pPre;
        pPre = head;
        head = pNext;
    }
    return pPre
};
```

## 16.合并两个排序的链表 - 7.29 （不懂）

### 题目描述

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

### 解析

有两种方法：

- 方法一：新建一个链表c，然后AB 分别比较，谁小放到c中，然后c.next = merge(小的next，打的) 进行递归。直到A或B为空
- 方法二：不新建链表，直接在A或B中进行比较排序

这里使用的是方法一

### 代码

```javascript
var merge = function(pHead1, pHead2) {
    let pHead3 = null;
    if (pHead1 === null) { return pHead2 };
    if (pHead2 === null) { return pHead1 };
    if (pHead1.val < pHead2.val) {
        pHead3 = pHead1;
        pHead3.next = merge(pHead1.next, pHead2);
    } else {
        pHead3 = pHead2;
        pHead3.next = merge(pHead1, pHead2.next);
    }
    return pHead3
}
```

## 17.树的子结构 - 7.29 （不懂）

### 题目描述

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

**示例 1：**

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

### 解析

看到树想到递归，先找A中是否有B的跟节点，然后递归

设计两个函数：

isSubStructure 的职能：判断 B 是否是 A 的子结构。是，返回 true；否则，尝试 A 的左右子树
isSubTree 的职能：封装“判断 B 是否是 A 的子结构”的具体逻辑。

### 代码

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} A
 * @param {TreeNode} B
 * @return {boolean}
 */
var isSubStructure = function(A, B) {
    if (!A || !B) {
        return false
    };
    return (
        isSubTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)
    )
};

var isSubTree = function(pRoot1, pRoot2) {
     if (!pRoot2) {
        return true
    }
    if (!pRoot1) {
        return false
    }
   
    if (pRoot1.val !== pRoot2.val) {
        return false
    }
    return  isSubTree(pRoot1.left, pRoot2.left) && isSubTree(pRoot1.right, pRoot2.right)
    
}
```

## 18.二叉树的镜像 - 7.30(不懂)

### 题目描述

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

**示例 1：**

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

### 解析

用递归，

虽然简单，但不懂递归 递归了什么

也不知道这个函数返回了什么

### 代码

```javascript
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */
function Mirror(root) {
    // write code here
    if (root) return false;
    Mirror(root.left);
    Mirror(root.right);
    [root.left, root.right] = [root.right, root.left];
    return root
}
```

### 补充

看来树和链表都不太行，都需要理解

## 19. 顺时针打印矩阵 - 7.30

### 题目描述

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

**示例 1：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

### 解析

自己在纸上画画，先考虑外围走一圈的情况。

总结下来 还挺简单的，就是自己思考比较久，而且没考虑pop和shift方法

### 代码

```javascript
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    let newArr = [];
    let flag = true;

    while (matrix.length) {
        // 从左到右
        if (flag) {
            // 第一层
            newArr = newArr.concat(matrix.shift());
            // matrix.length-1 这里是个坑，注意
            // "现在"的第一层到最后第一层的末尾
            for (let i = 0; i < matrix.length - 1; i++) {
                matrix[i].length && newArr.push(matrix[i].pop());
            }
        } else {
            // 从右到左
            // 最后一层
            newArr = newArr.concat(matrix.pop().reverse());
            // 现在matrix.length-1 这里也是坑
            // 现在的最后一层到第一层的开端
            for (let i = matrix.length - 1; i > 0; i--) {
                matrix[i].length && newArr.push(matrix[i].shift());
            }
        }
        flag = !flag;
    }
    return newArr;
};
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
console.log(spiralOrder(matrix));
```

### 注意点：坑

一开始const = matrix.length，想方便一点定义行数，但由于原数组在不断地pop和shift 第一行和最后一行被拿出去，所以length是不断变化的，就算用let也不可以

当把第一层shift后，注意 原数组的第二行是现在的第一行，matrix.length也减一了

同理 最后一层pop后，原来的倒数第二层成为倒数第一层

自己想的思路一样，但是弹出第一层和最后一层没想到用pop和shift方法，还傻傻的用arr[0] 和a[lentg-1]

## 20. 包含min函数的栈 - 7.31

### 题目描述

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

### 解析

其实这个题并不难，只不过 是第一次写数据结构。

push方法，stack是直接push，minStack是要比较一下的，minStack最顶上的值和要插入的数据x对比，如果data >= x，则push（x）。这里有个坑，之前我是data > x没有等于情况，报错了

top方法，是取栈的最上面的数据。

### 代码

```javascript
var Minstack = function() {
    this.dataStack = [];
    this.minStack = []; //辅助栈
}
Minstack.prototype.push = function(x) {
    const length = this.minStack.length;
    this.dataStack.push(x);
    if (length) {
        this.minStack[length - 1] >= x && this.minStack.push(x);
    } else {
        this.minStack.push(x);
    }
}
Minstack.prototype.pop = function() {
    if (this.minStack[this.minStack.length - 1] === this.dataStack[this.dataStack.length - 1]) {
        this.minStack.pop();
    }
    this.dataStack.pop();
}
Minstack.prototype.top = function() {
    const length = this.dataStack.length;
    if (length) return this.dataStack[length - 1];
    else return null
}
Minstack.prototype.min = function() {
    const length = this.minStack.length
    if (length) return this.minStack[length - 1];
    else return null;
}
```

### 补充：stack[stack.length - 1]

JavaScript是根据数组来实现堆和栈的，在数组末端添加数据push 

调用`stack.push(data)` 和`stack[length] = data`是一样的

访问栈的最顶端，也可以像数组一样 `top = stack[length-1]`

但是由于栈是后进先出 LIFO 特点，所以数据只能在 **栈的顶端** 添加或者删除

