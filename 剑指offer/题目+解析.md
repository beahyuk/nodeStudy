# 剑指offer（JavaScript版本）

## 1. 数组查找

### 题目描述

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

### 解析

因为数组是行递增，列递增，找到数组最左下角的数a进行判断，如果大于a，就往右走，col++。如果小于a，就往上找，row--

### 代码

```javascript
let array = [
    [1, 2, 3, 4, 5],
    [11, 12, 13, 14, 15],
    [21, 22, 23, 24, 25],
    [31, 32, 33, 34, 35]
];

function find(array, target) {
    let rowlen = array.length,
        collen = array[0].length;
    let row = rowlen - 1,
        col = 0;
    if (rowlen === 0 && collen === 0) {
        return -1
    }
    while (row >= 0 && col <= collen - 1) {
        if (target > array[row][col]) {
            col++;
        } else if (target < array[row][col]) {
            row--;
        } else return [row, col, array[row][col]]
    }
    return false
}

console.log(find(array, 23))
```



### 二分法查找数据

```javascript
let array = [1,3,2,7,4]; //乱序
//递增排序，二分法只适合递增数组
array.sort((a,b)=>a-b);
let end= array.length-1,
    start = 0;
let result = fn(array,2,start,end)
console.log(result);

function fn(array,target,start,end){
    if (start>end){
        return -1
    };
    let mid = parseInt((start+end)/2);
    if(target < array[mid]){
        end = mid-1;
        return fn(array,target,start,end);
    }else if(target > array[mid]){
        start = mid+1;
        return fn(array,target,start,end);
    }else{
        return mid
    };
};

```

## 2. 替换空格（简单）

### 题目描述

请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

### 解析

利用正则表达式 将空格转成%20

### 代码

```javascript
var replaceSpace = function(s) {
    return s.replace(/ /g, "%20");
    // \s 是匹配任何空白字符，包括空格，制表符，换页符等等
    // return s.replace(/\s/g, "%20");

};

let str = "we are happy";
console.log(replaceSpace(str))
```

## 3. 从尾到头打印链表（简单）（不懂）

### 题目描述

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

### 解析

逆序输出链表，可以利用数组的unshift方法，输出放在数组头部

然后让指针指向下一个

### 代码

```javascript
function reverPrint(head1) {
    let res = [];
    let pNode = head;
    while (pNode !== null) {
        res.unshift(pNode.val);
        pNode = pNode.next;
    }
    return res
}
```

## 4.重建二叉树(不懂)

### 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

### 解析

先根据前序的第一个是根节点，然后在中序中 以根节点为中心，一分为二，再对左右分别进行递归查找

### 代码

```javascript
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    // preorder:前序，中左右
    // inorder：中序，左中右
    /**
     * @param {number[]} preorder
     * @param {number[]} inorder
     * @return {TreeNode}
     */
    var buildTree = function(preorder, inorder) {
        if (preorder.length == 0 || inorder.length == 0) {
            return null
        }

        // 找到根位置，（0，根位置）是左边树，（根位置，末尾）是右边树
        const index = inorder.indexOf(preorder[0]);
        let left = inorder.slice(0, index),
            right = inorder.slice(index + 1);
        return {
            val: preorder[0],
            left: buildTree(preorder.slice(1, index + 1), left);
            right: buildTree(preorder.slice(index + 1), right)
        }
    };
```

3和4 在本地运行的时候，不懂构造函数TreeNode，this.val = val,this.right =right 指向

## 5.用两个栈实现队列

### 题目描述

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

### 解析

栈的特性是：后入先出。根据题目提示，使用 2 个栈即可。一个栈inStack用来存储插入队列的数据，一个栈outStack用来从队列中取出数据。

算法分为入队和出队过程。

入队过程：将元素放入 inStack 中。

出队过程：

outStack 不为空：弹出元素
outStack 为空：将 inStack 元素依次弹出，放入到 outStack 中（在数据转移过程中，顺序已经从后入先出变成了先入先出）
时间复杂度是 O(N)，空间复杂度是 O(N)。

### 代码

```javascript
var CQueue = function() {
    this.instack = [];
    this.outstack = []
};

CQueue.prototype.appendTail = function(value) {
    this.instack.push(value)
};

CQueue.prototype.deleteHead = function() {
    const { instack, outstack } = this;
    if (outstack.length) {
        return outstack.pop()
    } else {
        while (!instack.length) {
            outstack.push(instack.pop())
        }
        return outstack.pop() || -1
    }
}
```

## 6.旋转数组中的最小数字

### 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输入旋转数组的最小元素。例如，数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1

### 解析

原数组递增排序，那么该数组的所有片段都是递增排列，第一个不符合递增排列的元素就是旋转截断点，也就是最小值点，如果没有，就返回第一个元素

对数组进行遍历，因为原数组是递增的，所以如果找到比数组的第一个元素小的，返回这个小的数，否则就返回第一个元素

### 代码

```javascript
let arr = [3, 4, 5, 1, 2];
/**
 * @param {number[]} numbers
 * @return {number}
 */
var minArray = function(numbers) {
    if (numbers.length === 0) return 0
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] < numbers[0]) {
            return numbers[i]
        }
    }
    return numbers[0]
}
console.log(minArray(arr))
```

## 7.斐波那契数-7.22

### 题目描述

斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
给定 N，计算 F(N)。

首几个斐波那契数是：（从第二个开始是前两个数的和）

0,1,1,2,3,5,13,21,34

### 解析

由于斐波那契数，从第二个开始是前两个数的和，除了第0个和 第一个。

第一反应是用递归，但是递归算法时间复杂度大

采用动态规划，把每一个值都存储起来，最后返回最后一个值，就是F（N）

### 代码

```javascript
var fn = function(N){
    let arr = [0,1,1]; //现规定前三个数
    for(let i = 3; i <= N; i++){
        arr[i]=arr[i-1]+arr[i-2]
    };
    return arr[N]  // 返回最后一个值
}
console.log(fn(5))
```

